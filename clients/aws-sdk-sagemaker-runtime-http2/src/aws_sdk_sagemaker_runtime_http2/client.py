# Code generated by smithy-python-codegen DO NOT EDIT.

from copy import deepcopy
import logging

from smithy_core.aio.client import ClientCall, RequestPipeline
from smithy_core.aio.eventstream import DuplexEventStream
from smithy_core.exceptions import ExpectationNotMetError
from smithy_core.interceptors import InterceptorChain
from smithy_core.interfaces.retries import RetryStrategy
from smithy_core.retries import RetryStrategyOptions, RetryStrategyResolver
from smithy_core.types import TypedProperties
from smithy_http.plugins import user_agent_plugin

from .config import Config, Plugin
from .models import (
    INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM,
    InvokeEndpointWithBidirectionalStreamInput,
    InvokeEndpointWithBidirectionalStreamOutput,
    RequestStreamEvent,
    ResponseStreamEvent,
    _ResponseStreamEventDeserializer,
)
from .user_agent import aws_user_agent_plugin


logger = logging.getLogger(__name__)


class SageMakerRuntimeHTTP2Client:
    """
     The Amazon SageMaker AI runtime HTTP/2 API.

    :param config: Optional configuration for the client. Here you can set things like the
        endpoint for HTTP services or auth credentials.

    :param plugins: A list of callables that modify the configuration dynamically. These
        can be used to set defaults, for example.
    """

    def __init__(
        self, config: Config | None = None, plugins: list[Plugin] | None = None
    ):
        self._config = config or Config()

        client_plugins: list[Plugin] = [aws_user_agent_plugin, user_agent_plugin]
        if plugins:
            client_plugins.extend(plugins)

        for plugin in client_plugins:
            plugin(self._config)

        self._retry_strategy_resolver = RetryStrategyResolver()

    async def invoke_endpoint_with_bidirectional_stream(
        self,
        input: InvokeEndpointWithBidirectionalStreamInput,
        plugins: list[Plugin] | None = None,
    ) -> DuplexEventStream[
        RequestStreamEvent,
        ResponseStreamEvent,
        InvokeEndpointWithBidirectionalStreamOutput,
    ]:
        """
        Invokes a model endpoint with bidirectional streaming capabilities. This
        operation establishes a persistent connection that allows you to send multiple
        requests and receive streaming responses from the model in real-time.

        Bidirectional streaming is useful for interactive applications such as chatbots,
        real-time translation, or any scenario where you need to maintain a
        conversation-like interaction with the model. The connection remains open,
        allowing you to send additional input and receive responses without establishing
        a new connection for each request.

        For an overview of Amazon SageMaker AI, see `How It Works <https://docs.aws.amazon.com/sagemaker/latest/dg/how-it-works.html>`_
        .

        Amazon SageMaker AI strips all POST headers except those supported by the API.
        Amazon SageMaker AI might add additional headers. You should not rely on the
        behavior of headers outside those enumerated in the request syntax.

        Calls to ``InvokeEndpointWithBidirectionalStream`` are authenticated by using Amazon Web Services Signature Version 4. For information, see `Authenticating Requests (Amazon Web Services Signature Version 4) <https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html>`_
        in the *Amazon S3 API Reference*.

        The bidirectional stream maintains the connection until either the client closes
        it or the model indicates completion. Each request and response in the stream is
        sent as an event with optional headers for data type and completion state.

        .. note::
            Endpoints are scoped to an individual account, and are not public. The URL does
            not contain the account ID, but Amazon SageMaker AI determines the account ID
            from the authentication token that is supplied by the caller.

        :param input: The operation's input.

        :param plugins: A list of callables that modify the configuration dynamically.
            Changes made by these plugins only apply for the duration of the operation
            execution and will not affect any other operation invocations.
        """
        operation_plugins: list[Plugin] = []
        if plugins:
            operation_plugins.extend(plugins)
        config = deepcopy(self._config)
        for plugin in operation_plugins:
            plugin(config)
        if config.protocol is None or config.transport is None:
            raise ExpectationNotMetError(
                "protocol and transport MUST be set on the config to make calls."
            )

        # Resolve retry strategy from config
        if isinstance(config.retry_strategy, RetryStrategy):
            retry_strategy = config.retry_strategy
        elif isinstance(config.retry_strategy, RetryStrategyOptions):
            retry_strategy = await self._retry_strategy_resolver.resolve_retry_strategy(
                options=config.retry_strategy
            )
        elif config.retry_strategy is None:
            retry_strategy = await self._retry_strategy_resolver.resolve_retry_strategy(
                options=RetryStrategyOptions()
            )
        else:
            raise TypeError(
                f"retry_strategy must be RetryStrategy, RetryStrategyOptions, or None, "
                f"got {type(config.retry_strategy).__name__}"
            )

        pipeline = RequestPipeline(protocol=config.protocol, transport=config.transport)
        call = ClientCall(
            input=input,
            operation=INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM,
            context=TypedProperties({"config": config}),
            interceptor=InterceptorChain(config.interceptors),
            auth_scheme_resolver=config.auth_scheme_resolver,
            supported_auth_schemes=config.auth_schemes,
            endpoint_resolver=config.endpoint_resolver,
            retry_strategy=retry_strategy,
        )

        return await pipeline.duplex_stream(
            call,
            RequestStreamEvent,
            ResponseStreamEvent,
            _ResponseStreamEventDeserializer().deserialize,
        )
