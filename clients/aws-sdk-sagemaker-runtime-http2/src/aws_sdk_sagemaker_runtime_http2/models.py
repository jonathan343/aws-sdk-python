# Code generated by smithy-python-codegen DO NOT EDIT.

from dataclasses import dataclass, field
import logging
from typing import Any, Literal, Self, Union

from smithy_core.deserializers import ShapeDeserializer
from smithy_core.documents import TypeRegistry
from smithy_core.exceptions import ModeledError, SerializationError
from smithy_core.schemas import APIOperation, Schema
from smithy_core.serializers import ShapeSerializer
from smithy_core.shapes import ShapeID

from ._private.schemas import (
    INPUT_VALIDATION_ERROR as _SCHEMA_INPUT_VALIDATION_ERROR,
    INTERNAL_SERVER_ERROR as _SCHEMA_INTERNAL_SERVER_ERROR,
    INTERNAL_STREAM_FAILURE as _SCHEMA_INTERNAL_STREAM_FAILURE,
    INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM as _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM,
    INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT as _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT,
    INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT as _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT,
    MODEL_ERROR as _SCHEMA_MODEL_ERROR,
    MODEL_STREAM_ERROR as _SCHEMA_MODEL_STREAM_ERROR,
    REQUEST_PAYLOAD_PART as _SCHEMA_REQUEST_PAYLOAD_PART,
    REQUEST_STREAM_EVENT as _SCHEMA_REQUEST_STREAM_EVENT,
    RESPONSE_PAYLOAD_PART as _SCHEMA_RESPONSE_PAYLOAD_PART,
    RESPONSE_STREAM_EVENT as _SCHEMA_RESPONSE_STREAM_EVENT,
    SERVICE_UNAVAILABLE_ERROR as _SCHEMA_SERVICE_UNAVAILABLE_ERROR,
)


logger = logging.getLogger(__name__)


class ServiceError(ModeledError):
    """
    Base error for all errors in the service.

    Some exceptions do not extend from this class, including
    synthetic, implicit, and shared exception types.
    """


@dataclass(kw_only=True)
class InputValidationError(ServiceError):
    """The input fails to satisfy the constraints specified by an AWS service."""

    fault: Literal["client", "server"] | None = "client"

    error_code: str | None = None
    """Error code."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_INPUT_VALIDATION_ERROR, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_INPUT_VALIDATION_ERROR.members["Message"], self.message
            )

        if self.error_code is not None:
            serializer.write_string(
                _SCHEMA_INPUT_VALIDATION_ERROR.members["ErrorCode"], self.error_code
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_INPUT_VALIDATION_ERROR.members["Message"]
                    )

                case 1:
                    kwargs["error_code"] = de.read_string(
                        _SCHEMA_INPUT_VALIDATION_ERROR.members["ErrorCode"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_INPUT_VALIDATION_ERROR, consumer=_consumer)
        return kwargs


@dataclass(kw_only=True)
class InternalServerError(ServiceError):
    """
    The request processing has failed because of an unknown error, exception
    or failure.
    """

    fault: Literal["client", "server"] | None = "server"

    error_code: str | None = None
    """Error code."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_INTERNAL_SERVER_ERROR, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_INTERNAL_SERVER_ERROR.members["Message"], self.message
            )

        if self.error_code is not None:
            serializer.write_string(
                _SCHEMA_INTERNAL_SERVER_ERROR.members["ErrorCode"], self.error_code
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_INTERNAL_SERVER_ERROR.members["Message"]
                    )

                case 1:
                    kwargs["error_code"] = de.read_string(
                        _SCHEMA_INTERNAL_SERVER_ERROR.members["ErrorCode"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_INTERNAL_SERVER_ERROR, consumer=_consumer)
        return kwargs


@dataclass(kw_only=True)
class InternalStreamFailure(ServiceError):
    """Internal stream failure that occurs during streaming."""

    fault: Literal["client", "server"] | None = "server"

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_INTERNAL_STREAM_FAILURE, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_INTERNAL_STREAM_FAILURE.members["Message"], self.message
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_INTERNAL_STREAM_FAILURE.members["Message"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_INTERNAL_STREAM_FAILURE, consumer=_consumer)
        return kwargs


@dataclass(kw_only=True)
class RequestPayloadPart:
    """Request payload part structure."""

    bytes_: bytes | None = field(repr=False, default=None)
    """The payload bytes."""

    data_type: str | None = None
    """
    Data type header. Can be one of these possible values: \"UTF8\",
    \"BINARY\".
    """

    completion_state: str | None = None
    """
    Completion state header. Can be one of these possible values:
    \"PARTIAL\", \"COMPLETE\".
    """

    p: str | None = None
    """Padding string for alignment."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_REQUEST_PAYLOAD_PART, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.bytes_ is not None:
            serializer.write_blob(
                _SCHEMA_REQUEST_PAYLOAD_PART.members["Bytes"], self.bytes_
            )

        if self.data_type is not None:
            serializer.write_string(
                _SCHEMA_REQUEST_PAYLOAD_PART.members["DataType"], self.data_type
            )

        if self.completion_state is not None:
            serializer.write_string(
                _SCHEMA_REQUEST_PAYLOAD_PART.members["CompletionState"],
                self.completion_state,
            )

        if self.p is not None:
            serializer.write_string(_SCHEMA_REQUEST_PAYLOAD_PART.members["P"], self.p)

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["bytes_"] = de.read_blob(
                        _SCHEMA_REQUEST_PAYLOAD_PART.members["Bytes"]
                    )

                case 1:
                    kwargs["data_type"] = de.read_string(
                        _SCHEMA_REQUEST_PAYLOAD_PART.members["DataType"]
                    )

                case 2:
                    kwargs["completion_state"] = de.read_string(
                        _SCHEMA_REQUEST_PAYLOAD_PART.members["CompletionState"]
                    )

                case 3:
                    kwargs["p"] = de.read_string(
                        _SCHEMA_REQUEST_PAYLOAD_PART.members["P"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_REQUEST_PAYLOAD_PART, consumer=_consumer)
        return kwargs


@dataclass
class RequestStreamEventPayloadPart:
    """Payload part event."""

    value: RequestPayloadPart

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_REQUEST_STREAM_EVENT, self)

    def serialize_members(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_REQUEST_STREAM_EVENT.members["PayloadPart"], self.value
        )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(value=RequestPayloadPart.deserialize(deserializer))


@dataclass
class RequestStreamEventUnknown:
    """
    Represents an unknown variant.

    If you receive this value, you will need to update your library to receive the
    parsed value.

    This value may not be deliberately sent.
    """

    tag: str

    def serialize(self, serializer: ShapeSerializer):
        raise SerializationError("Unknown union variants may not be serialized.")

    def serialize_members(self, serializer: ShapeSerializer):
        raise SerializationError("Unknown union variants may not be serialized.")

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        raise NotImplementedError()


RequestStreamEvent = Union[RequestStreamEventPayloadPart | RequestStreamEventUnknown]
"""Request stream event union."""


class _RequestStreamEventDeserializer:
    _result: RequestStreamEvent | None = None

    def deserialize(self, deserializer: ShapeDeserializer) -> RequestStreamEvent:
        self._result = None
        deserializer.read_struct(_SCHEMA_REQUEST_STREAM_EVENT, self._consumer)

        if self._result is None:
            raise SerializationError(
                "Unions must have exactly one value, but found none."
            )

        return self._result

    def _consumer(self, schema: Schema, de: ShapeDeserializer) -> None:
        match schema.expect_member_index():
            case 0:
                self._set_result(RequestStreamEventPayloadPart.deserialize(de))

            case _:
                logger.debug("Unexpected member schema: %s", schema)

    def _set_result(self, value: RequestStreamEvent) -> None:
        if self._result is not None:
            raise SerializationError(
                "Unions must have exactly one value, but found more than one."
            )
        self._result = value


@dataclass(kw_only=True)
class InvokeEndpointWithBidirectionalStreamInput:
    """Dataclass for InvokeEndpointWithBidirectionalStreamInput structure."""

    endpoint_name: str | None = None
    """The name of the endpoint to invoke."""

    target_variant: str | None = None
    """Target variant for the request."""

    model_invocation_path: str | None = None
    """Model invocation path."""

    model_query_string: str | None = None
    """Model query string."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT, self
        )

    def serialize_members(self, serializer: ShapeSerializer):
        if self.endpoint_name is not None:
            serializer.write_string(
                _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                    "EndpointName"
                ],
                self.endpoint_name,
            )

        if self.target_variant is not None:
            serializer.write_string(
                _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                    "TargetVariant"
                ],
                self.target_variant,
            )

        if self.model_invocation_path is not None:
            serializer.write_string(
                _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                    "ModelInvocationPath"
                ],
                self.model_invocation_path,
            )

        if self.model_query_string is not None:
            serializer.write_string(
                _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                    "ModelQueryString"
                ],
                self.model_query_string,
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["endpoint_name"] = de.read_string(
                        _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                            "EndpointName"
                        ]
                    )

                case 2:
                    kwargs["target_variant"] = de.read_string(
                        _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                            "TargetVariant"
                        ]
                    )

                case 3:
                    kwargs["model_invocation_path"] = de.read_string(
                        _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                            "ModelInvocationPath"
                        ]
                    )

                case 4:
                    kwargs["model_query_string"] = de.read_string(
                        _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT.members[
                            "ModelQueryString"
                        ]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(
            _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT, consumer=_consumer
        )
        return kwargs


@dataclass(kw_only=True)
class ModelStreamError(ServiceError):
    """Model stream error that occurs during streaming."""

    fault: Literal["client", "server"] | None = "client"

    error_code: str | None = None
    """Error code."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_MODEL_STREAM_ERROR, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_MODEL_STREAM_ERROR.members["Message"], self.message
            )

        if self.error_code is not None:
            serializer.write_string(
                _SCHEMA_MODEL_STREAM_ERROR.members["ErrorCode"], self.error_code
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_MODEL_STREAM_ERROR.members["Message"]
                    )

                case 1:
                    kwargs["error_code"] = de.read_string(
                        _SCHEMA_MODEL_STREAM_ERROR.members["ErrorCode"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_MODEL_STREAM_ERROR, consumer=_consumer)
        return kwargs


@dataclass(kw_only=True)
class ResponsePayloadPart:
    """Response payload part structure."""

    bytes_: bytes | None = field(repr=False, default=None)
    """The payload bytes."""

    data_type: str | None = None
    """
    Data type header. Can be one of these possible values: \"UTF8\",
    \"BINARY\".
    """

    completion_state: str | None = None
    """
    Completion state header. Can be one of these possible values:
    \"PARTIAL\", \"COMPLETE\".
    """

    p: str | None = None
    """Padding string for alignment."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_RESPONSE_PAYLOAD_PART, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.bytes_ is not None:
            serializer.write_blob(
                _SCHEMA_RESPONSE_PAYLOAD_PART.members["Bytes"], self.bytes_
            )

        if self.data_type is not None:
            serializer.write_string(
                _SCHEMA_RESPONSE_PAYLOAD_PART.members["DataType"], self.data_type
            )

        if self.completion_state is not None:
            serializer.write_string(
                _SCHEMA_RESPONSE_PAYLOAD_PART.members["CompletionState"],
                self.completion_state,
            )

        if self.p is not None:
            serializer.write_string(_SCHEMA_RESPONSE_PAYLOAD_PART.members["P"], self.p)

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["bytes_"] = de.read_blob(
                        _SCHEMA_RESPONSE_PAYLOAD_PART.members["Bytes"]
                    )

                case 1:
                    kwargs["data_type"] = de.read_string(
                        _SCHEMA_RESPONSE_PAYLOAD_PART.members["DataType"]
                    )

                case 2:
                    kwargs["completion_state"] = de.read_string(
                        _SCHEMA_RESPONSE_PAYLOAD_PART.members["CompletionState"]
                    )

                case 3:
                    kwargs["p"] = de.read_string(
                        _SCHEMA_RESPONSE_PAYLOAD_PART.members["P"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_RESPONSE_PAYLOAD_PART, consumer=_consumer)
        return kwargs


@dataclass
class ResponseStreamEventPayloadPart:
    """Payload part event."""

    value: ResponsePayloadPart

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_RESPONSE_STREAM_EVENT, self)

    def serialize_members(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_RESPONSE_STREAM_EVENT.members["PayloadPart"], self.value
        )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(value=ResponsePayloadPart.deserialize(deserializer))


@dataclass
class ResponseStreamEventModelStreamError:
    """Model stream error event."""

    value: ModelStreamError

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_RESPONSE_STREAM_EVENT, self)

    def serialize_members(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_RESPONSE_STREAM_EVENT.members["ModelStreamError"], self.value
        )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(value=ModelStreamError.deserialize(deserializer))


@dataclass
class ResponseStreamEventInternalStreamFailure:
    """Internal stream failure event."""

    value: InternalStreamFailure

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_RESPONSE_STREAM_EVENT, self)

    def serialize_members(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_RESPONSE_STREAM_EVENT.members["InternalStreamFailure"], self.value
        )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(value=InternalStreamFailure.deserialize(deserializer))


@dataclass
class ResponseStreamEventUnknown:
    """
    Represents an unknown variant.

    If you receive this value, you will need to update your library to receive the
    parsed value.

    This value may not be deliberately sent.
    """

    tag: str

    def serialize(self, serializer: ShapeSerializer):
        raise SerializationError("Unknown union variants may not be serialized.")

    def serialize_members(self, serializer: ShapeSerializer):
        raise SerializationError("Unknown union variants may not be serialized.")

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        raise NotImplementedError()


ResponseStreamEvent = Union[
    ResponseStreamEventPayloadPart
    | ResponseStreamEventModelStreamError
    | ResponseStreamEventInternalStreamFailure
    | ResponseStreamEventUnknown
]
"""Response stream event union."""


class _ResponseStreamEventDeserializer:
    _result: ResponseStreamEvent | None = None

    def deserialize(self, deserializer: ShapeDeserializer) -> ResponseStreamEvent:
        self._result = None
        deserializer.read_struct(_SCHEMA_RESPONSE_STREAM_EVENT, self._consumer)

        if self._result is None:
            raise SerializationError(
                "Unions must have exactly one value, but found none."
            )

        return self._result

    def _consumer(self, schema: Schema, de: ShapeDeserializer) -> None:
        match schema.expect_member_index():
            case 0:
                self._set_result(ResponseStreamEventPayloadPart.deserialize(de))

            case 1:
                self._set_result(ResponseStreamEventModelStreamError.deserialize(de))

            case 2:
                self._set_result(
                    ResponseStreamEventInternalStreamFailure.deserialize(de)
                )

            case _:
                logger.debug("Unexpected member schema: %s", schema)

    def _set_result(self, value: ResponseStreamEvent) -> None:
        if self._result is not None:
            raise SerializationError(
                "Unions must have exactly one value, but found more than one."
            )
        self._result = value


@dataclass(kw_only=True)
class InvokeEndpointWithBidirectionalStreamOutput:
    """Dataclass for InvokeEndpointWithBidirectionalStreamOutput structure."""

    invoked_production_variant: str | None = None
    """The invoked production variant."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(
            _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT, self
        )

    def serialize_members(self, serializer: ShapeSerializer):
        if self.invoked_production_variant is not None:
            serializer.write_string(
                _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT.members[
                    "InvokedProductionVariant"
                ],
                self.invoked_production_variant,
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 1:
                    kwargs["invoked_production_variant"] = de.read_string(
                        _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT.members[
                            "InvokedProductionVariant"
                        ]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(
            _SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT, consumer=_consumer
        )
        return kwargs


@dataclass(kw_only=True)
class ModelError(ServiceError):
    """An error occurred while processing the model."""

    fault: Literal["client", "server"] | None = "client"

    original_status_code: int | None = None
    """HTTP status code returned by model."""

    original_message: str | None = None
    """Original error message from the model."""

    log_stream_arn: str | None = None
    """CloudWatch log stream ARN."""

    error_code: str | None = None
    """Error code."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_MODEL_ERROR, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_MODEL_ERROR.members["Message"], self.message
            )

        if self.original_status_code is not None:
            serializer.write_integer(
                _SCHEMA_MODEL_ERROR.members["OriginalStatusCode"],
                self.original_status_code,
            )

        if self.original_message is not None:
            serializer.write_string(
                _SCHEMA_MODEL_ERROR.members["OriginalMessage"], self.original_message
            )

        if self.log_stream_arn is not None:
            serializer.write_string(
                _SCHEMA_MODEL_ERROR.members["LogStreamArn"], self.log_stream_arn
            )

        if self.error_code is not None:
            serializer.write_string(
                _SCHEMA_MODEL_ERROR.members["ErrorCode"], self.error_code
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_MODEL_ERROR.members["Message"]
                    )

                case 1:
                    kwargs["original_status_code"] = de.read_integer(
                        _SCHEMA_MODEL_ERROR.members["OriginalStatusCode"]
                    )

                case 2:
                    kwargs["original_message"] = de.read_string(
                        _SCHEMA_MODEL_ERROR.members["OriginalMessage"]
                    )

                case 3:
                    kwargs["log_stream_arn"] = de.read_string(
                        _SCHEMA_MODEL_ERROR.members["LogStreamArn"]
                    )

                case 4:
                    kwargs["error_code"] = de.read_string(
                        _SCHEMA_MODEL_ERROR.members["ErrorCode"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_MODEL_ERROR, consumer=_consumer)
        return kwargs


@dataclass(kw_only=True)
class ServiceUnavailableError(ServiceError):
    """The request has failed due to a temporary failure of the server."""

    fault: Literal["client", "server"] | None = "server"

    error_code: str | None = None
    """Error code."""

    def serialize(self, serializer: ShapeSerializer):
        serializer.write_struct(_SCHEMA_SERVICE_UNAVAILABLE_ERROR, self)

    def serialize_members(self, serializer: ShapeSerializer):
        if self.message is not None:
            serializer.write_string(
                _SCHEMA_SERVICE_UNAVAILABLE_ERROR.members["Message"], self.message
            )

        if self.error_code is not None:
            serializer.write_string(
                _SCHEMA_SERVICE_UNAVAILABLE_ERROR.members["ErrorCode"], self.error_code
            )

    @classmethod
    def deserialize(cls, deserializer: ShapeDeserializer) -> Self:
        return cls(**cls.deserialize_kwargs(deserializer))

    @classmethod
    def deserialize_kwargs(cls, deserializer: ShapeDeserializer) -> dict[str, Any]:
        kwargs: dict[str, Any] = {}

        def _consumer(schema: Schema, de: ShapeDeserializer) -> None:
            match schema.expect_member_index():
                case 0:
                    kwargs["message"] = de.read_string(
                        _SCHEMA_SERVICE_UNAVAILABLE_ERROR.members["Message"]
                    )

                case 1:
                    kwargs["error_code"] = de.read_string(
                        _SCHEMA_SERVICE_UNAVAILABLE_ERROR.members["ErrorCode"]
                    )

                case _:
                    logger.debug("Unexpected member schema: %s", schema)

        deserializer.read_struct(_SCHEMA_SERVICE_UNAVAILABLE_ERROR, consumer=_consumer)
        return kwargs


INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM = APIOperation(
    input=InvokeEndpointWithBidirectionalStreamInput,
    output=InvokeEndpointWithBidirectionalStreamOutput,
    schema=_SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM,
    input_schema=_SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_INPUT,
    output_schema=_SCHEMA_INVOKE_ENDPOINT_WITH_BIDIRECTIONAL_STREAM_OUTPUT,
    error_registry=TypeRegistry(
        {
            ShapeID(
                "com.amazonaws.sagemakerruntimehttp2#InputValidationError"
            ): InputValidationError,
            ShapeID(
                "com.amazonaws.sagemakerruntimehttp2#InternalServerError"
            ): InternalServerError,
            ShapeID(
                "com.amazonaws.sagemakerruntimehttp2#InternalStreamFailure"
            ): InternalStreamFailure,
            ShapeID("com.amazonaws.sagemakerruntimehttp2#ModelError"): ModelError,
            ShapeID(
                "com.amazonaws.sagemakerruntimehttp2#ModelStreamError"
            ): ModelStreamError,
            ShapeID(
                "com.amazonaws.sagemakerruntimehttp2#ServiceUnavailableError"
            ): ServiceUnavailableError,
        }
    ),
    effective_auth_schemes=[ShapeID("aws.auth#sigv4")],
)
